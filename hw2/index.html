<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: Kunhong Lyu, Isabella Hu </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw2-meshedit-cooked.git">github.com/cal-cs184/hw2-meshedit-cooked.git</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		<p>In this assignment, we implemented several fundamental computer
			 graphics techniques for mesh processing and topology operations:</p>

		<ul>
		<li><strong>Bézier Curves and Surfaces:</strong> 
			Applied de Casteljau’s algorithm to recursively interpolate points along Bézier curves based on control points.
			We extended this same technique to Bézier surfaces by first applying the algorithm in one parametric direction, 
			then using those intermediate points as input to apply de Casteljau for the the other direction.
		</li>
		
		<li><strong>Triangle Mesh Operations:</strong> 
			Implemented proper normal calculations, which combined with Bézier curves to produce smoother shading. 
			Using the half-edge data structure, we built edge flipping and splitting operations, 
			then combined them to implement Loop subdivision for mesh operation.
		</li>
		</ul>

		<p>These techniques provide the foundation for modern modeling and animation systems, 
		enabling geometric transformations, motion path generation, etc.</p>

		<p>An interesting thing I learned: I finally understood how half-edge works, as I saw
			 that working with lower-level structures required a lot of tedious work such as manually reassign edges,
			  half-edges, and face, etc.</p>


		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: De Casteljau Algorithm</h3>
			<p>The De Casteljau algorithm recursively evaluates Bézier curves:</p>

			<ul>
			<li>Takes a set of Bézier curve control points as input</li>
			<li>Uses linear interpolation to evaluate points at parameter t</li>
			</ul>

			<p>Implementation steps:</p>
			<ol>
			<li>Perform linear interpolation: (1-t)a<sub>i</sub> + ta<sub>i+1</sub> on consecutive control points at parameter t</li>
			<li>Repeat interpolation on the resulting points until only one point remains - this is the point on the Bézier curve at time t</li>
			</ol>

			<p>For Part 1, since we only needed to return the vector of new points after one De Casteljau step, so recursion wasn't needed.</p>
			

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
					<td style="text-align: center;">
						<img src="bzc/t0.png" width="200px"/>
						<figcaption>Step = 0 (control pt)</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="bzc/t1.png" width="200px"/>
						<figcaption>Step = 1</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="bzc/t2.png" width="200px"/>
						<figcaption>Step = 2</figcaption>
					</td>
				</tr>
				<tr>
					<td style="text-align: center;">
						<img src="bzc/t3.png" width="200px"/>
						<figcaption>Step = 3</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="bzc/t4.png" width="200px"/>
						<figcaption>Step = 4</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="bzc/t5.png" width="200px"/>
						<figcaption>Step = 5 (evaluated pt)</figcaption>
					</td>
				</tr>
				<tr>
					<td style="text-align: center;">
						<img src="bzc/change1.png" width="200px"/>
						<figcaption>param t modified</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="bzc/change2.png" width="200px"/>
						<figcaption>param t modified</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="bzc/control.png" width="200px"/>
						<figcaption>moved control point</figcaption>
					</td>
				</tr>
			</table>
		</div>
				
			
	
		<br>
		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<p>To extend de Casteljau's algorithm to Bézier surfaces given the parameters u and v:</p>
			<ol>
			<li>
				<strong>Evaluate each row at parameter u:</strong>
				<ul>
				<li>Apply <code>evaluate1D(..., u)</code> to each row of control points</li>
				<li>Store the result of each evaluation (a single point per row) in a new vector, named <code>grouping</code></li>
				</ul>
			</li>

			<li>
				<strong>Evaluate the resulting vector at parameter v:</strong>
				<ul>
				<li>Use the <code>grouping</code> vector from step 1</li>
				<li>Apply <code>evaluate1D(grouping, v)</code></li>
				<li>This reduces the vector to a single point, which is the Bézier surface value at (u, v)</li>
				</ul>
			</li>
			</ol>

			<p><strong>Implementation of evaluate1D helper function:</strong></p>
			<ul>
			<li>Recursively calls itself (<code>evaluate1D</code>) on a vector of points returned by <code>evaluateStep</code></li>
			<li>Continues until only one point remains - which is the point on the Bézier curve at time t</li>
			</ul>

		
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bzc/teapot1.png" width="200px"/>
				</td>
				<td style="text-align: center;">
				  <img src="bzc/teapot2.png" width="200px"/>
				</td>
				<figcaption>bez/teapot.bez evaluated by implementation</figcaption>
			  </tr>
			</table>
		</div>
		<br>



		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>

		<p>Implementation:</p>
			<ol>
			<li>
				<strong>Iterate over adjacent faces:</strong>
				<ul>
				<li>Using the half-edge data structure, set the pointer to a halfedge</li>
				<li>Start from the vertex's outgoing half-edge, traverse neighboring faces through halfedges using: <code>h = h→twin()→next()</code></li>
				<li>Use a <code>do-while</code> loop that checks the stopping condition after each iteration</li>
				<li>Terminate when returning to the initial half-edge</li>
				</ul>
			</li>
			
			<li>
				<strong>Compute face areas:</strong>
				<ul>
				<li>Implemented helper function: <code>getArea(FaceCIter f)</code>
				to calculates triangular face area using cross product:
					<br><code>Area = 0.5*||edge₁ × edge₂||</code>
				</li>the edges are calcualted from the tree vertices of that face. 
				</ul>
			</li>
			
			<li>
				<strong>Calculate final normal:</strong>
				<ul>
				<li>Sum all face normals weighted by their areas</li>
				<li>Normalize the resulting vector to unit length</li>
				</ul>
			</li>
		</ol>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="p3_flat.png" width="200px"/>
				  <figcaption>Flat shading</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="p3_phong.png" width="200px"/>
				  <figcaption>Phong shading</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<br>
		<h3>Part 4: Edge flip</h3>
		<p>Implementation:</p>
		<ol>
		<li><strong>Get all elements that will be effected by the flip using halfedge traversal:</strong>
			<ul>
			<li><b>Vertices:</b> v0 (bottom), v1 (top), v2 (left), v3 (right)</li>
			<li><b>Faces:</b> f0 (left face), f1 (right face)</li>
			<li><b>Halfedges:</b> h0 (main), h1 (top-left), h2 (bottom-left), h3 (twin), h4 (bottom-right), h5 (top-right)</li>
			</ul>
		</li>
		
		<li><strong>Reassign attributes:</strong>
			<ul>
			<li>Update <code>next()</code> relationships</li>
			<li>Reassign vertex and face connections for each halfedge</li>
			<li>Update <code>halfedge</code> references for vertices and faces</li>
			</ul>
		</li>
		</ol>

		<p><strong>Implementation Tip:</strong> Drawing both the original and new structures made 
			the reassignment process significantly easier than pure mental reasoning.</p>
				
	<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="noedgeflip.png" width="300px"/>
				  <figcaption>Before edge flips</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="edgeflip.png" width="300px"/>
				  <figcaption>After edge flips</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<br>
		<h3>Part 5: Edge split</h3>
			<p>The Edge split implementation logic is very similar to the edge flip one</p>

			<ol>
			<li><strong>Extract all existing elements that will be effected by the split:</strong>
				<ul>
				<li><b>Vertices:</b> v0, v1 (edge endpoints), v2, v3 (opposite vertices)</li>
				<li><b>Faces:</b> f0, f1 (adjacent triangles)</li>
				<li><b>Halfedges:</b> h0 (main), h1, h2, h3 (twin), h4, h5</li>
				</ul>
			</li>
			
			<li><strong>Create new elements:</strong>
				<ul>
				<li>New vertex <b>m</b> at midpoint of v0 and v1</li>
				<li>New faces f2, f3 for subdivided triangles</li>
				<li>New edges e1, e2, e3 connecting m to v2, v3, and v1</li>
				<li>New halfedges h6-h11</li>
				</ul>
			</li>
			
			<li><strong>Reassign all attributes:</strong>
				<ul>
				<li>Update connections for both existing and new elements</li>
				<li>Update pointers for halfedges, vertices, twins, edges, and faces</li>
				</ul>
			</li>
		</ol>

		<p><strong>Implementation Tip:</strong> Again, similar to edge flipping, a visualization of pre- and post-split diagrams help a lot during reassignment.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
					<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
						<img src="noedgeflip.png" width="275px"/>
						<figcaption>Before edge flips/edge split</figcaption>
						</td>
						<td style="text-align: center;">
						<img src="flipsplit.png" width="300px"/>
						<figcaption>After edge flips + edge split</figcaption>
						</td>
					</tr>
					</table>
				</div>


		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
			<p>Loop subdivision refines meshes by smoothing vertex positions through weighted averaging and splitting each triangle into four smaller triangles.</p>

			<h3>Implementation Steps</h3>

			<ol>
			<li>
				<strong>Compute Updated Positions for Original Vertices</strong>
				<p>For each original vertex, calculate a smoothed position using neighbor weighting:</p>
				<div style="text-align: center; margin: 10px 0;">
				<code>newPosition = (1 - n·u)·position + u·∑(neighbor positions)</code>
				</div>
				<ul>
				<li><b>n:</b> Number of adjacent vertices</li>
				<li><b>u:</b> Weight value (3/16 for n=3, otherwise 3/(8n))</li>
				</ul>
				<p><strong>Boundary Handling (Extra Credit):</strong></p>
				<p>For boundary vertices, use modified weighting:</p>
				<div style="text-align: center; margin: 10px 0;">
				<code>newPosition = 0.75·position + 0.125·(left_neighbor + right_neighbor)</code>
				</div>
			</li>

			<li>
				<strong>Compute New Edge Midpoint Positions</strong>
				<p>Calculate positions for new edge vertices:</p>
				<div style="text-align: center; margin: 10px 0;">
				<code>newPosition = (3/8)(A + B) + (1/8)(C + D)</code>
				</div>
				<ul>
				<li><b>A, B:</b> Edge endpoints</li>
				<li><b>C, D:</b> Opposite vertices of adjacent triangles</li>
				</ul>
			</li>

			<li>
				<strong>Split Every Edge</strong>
				<ul>
				<li>Store original edges in a temporary list to prevent modification during iteration</li>
				<li>Split each edge, creating a new vertex at its midpoint</li>
				<li>Mark newly created edges with <code>isNew = true</code></li>
				</ul>
			</li>

			<li>
				<strong>Flip New Edges Between Old & New Vertices</strong>
				<ul>
				<li>Flip edges connecting original vertices to newly created vertices</li>
				<li>Ensures even vertex distribution and prevents "pinching" artifacts</li>
				</ul>
			</li>

			<li>
				<strong>Update Final Vertex Positions</strong>
				<p>Transfer all calculated <code>newPosition</code> values to final <code>position</code> attributes</p>
			</li>
			</ol>



		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.


		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>
		
			<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="noedgeflip.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>



		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>